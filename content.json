[{"title":"关于Android进程间通信II","date":"2017-03-13T03:09:11.000Z","path":"2017/03/13/关于Android进程间通信II/","text":"在上一篇关于Android进程间通信中介绍了Android的三种进程间通信的方式。这里再介绍一种牛逼的IPC方式 AIDL 上次去面试一家心仪的公司，面试官有问道关于Android多进程通信相关的方法，我吧能想到的全都说了，但是没有说道一个让面试官满意的方式。是的，面试官要的答案就是AIDL实现进程间的通信。 上一篇文章中介绍的三种方式都有自己的局限性和缺点(这个在后面还会总结一下) 那么AIDL呢？近乎完美。 关于AIDL是什么，可以Google一下。这里我只给出自己对AIDL的理解： 一种实现进程间通信的方式。 IDE（eclipse 或者 studio）都会根据aidl文件自动生成对应的Java文件，实现接口的作用 在不同的进程之间实现序列化和反序列化同一个对象 可实现观察者模式的进程间通信 一个注意点：在Android studio中创建的aidl文件，studio会自动创建一个aidl文件夹，然后该文件夹下的类不能被Java文件夹下的类访问，需作如下处理： 修改gradle文件 123456789101112131415161718192021222324252627android &#123; compileSdkVersion xxx buildToolsVersion \"xxx\" defaultConfig &#123; xxx &#125; buildTypes &#123; release &#123; xxx &#125; &#125; sourceSets &#123; main &#123; manifest.srcFile 'src/main/AndroidManifest.xml' java.srcDirs = ['src/main/java', 'src/main/aidl'] resources.srcDirs = ['src/main/java', 'src/main/aidl'] aidl.srcDirs = ['src/main/aidl'] res.srcDirs = ['src/main/res'] assets.srcDirs = ['src/main/assets'] &#125; &#125;&#125;dependencies &#123; xxxx&#125; ok准备工作已经做好，开始你的表演 1 服务端与客户端的通信同样分为服务端和客户端 1.1 aidl文件在项目中创建一个专门的aidl包，里面放与aidl相关的文件，方便新进程中复制。 新建一个Books类，实现Parcelable接口让他可序列化。 Books.java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.example.root.androidart.somethingAboutAidl.bookAidl;import android.os.Parcel;import android.os.Parcelable;/** * Created by mzy on 17-3-6. */public class Books implements Parcelable&#123; private int bookId; private String bookName; private Books(Parcel in) &#123; bookId = in.readInt(); bookName = in.readString(); &#125; public Books(int bookId, String bookName)&#123; this.bookId = bookId; this.bookName = bookName; &#125; public static final Creator&lt;Books&gt; CREATOR = new Creator&lt;Books&gt;() &#123; @Override public Books createFromParcel(Parcel in) &#123; return new Books(in); &#125; @Override public Books[] newArray(int size) &#123; return new Books[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel parcel, int i) &#123; parcel.writeInt(bookId); parcel.writeString(bookName); &#125; public int getBookId() &#123; return bookId; &#125; public void setBookId(int bookId) &#123; this.bookId = bookId; &#125; public String getBookName() &#123; return bookName; &#125; public void setBookName(String bookName) &#123; this.bookName = bookName; &#125;&#125; 然后建立一个Books.aidl文件，和一个IBookManager.aidl文件Books.aidl代码 12345 // Books.aidlpackage com.example.root.androidart.somethingAboutAidl.bookAidl;// Declare any non-default types here with import statementsparcelable Books; IBookManager.aidl代码12345678910// IBookManager.aidlpackage com.example.root.androidart.somethingAboutAidl.bookAidl;import com.example.root.androidart.somethingAboutAidl.bookAidl.Books;// Declare any non-default types here with import statementsinterface IBookManager&#123; List&lt;Books&gt; getBookList(); void addBook(in Books books);&#125; 说明一下：在使用Bundle 或者Messenger实现进程间通信的时候在传递序列化对象时由于进程间无法共享类，所以会导致class not find 报错。这里aidl解决了这个问题。我们要做的是让两个进程能有相同的Books对象（只是相同的对象示例，不是同一个）在两个进程中都要写有相同的aidl文件（将服务端的aidl文件夹整个复制到客户端即可） 1.2服务端 服务端创建一个Service用来监听客户端的链接请求，然后创建一个AIDL文件，将暴露给客户端的接口在AIDL中申明，最后在Service中实现这个AIDL接口 实现代码： 1234567891011121314151617181920212223242526272829public class BookManagerService extends Service &#123; private CopyOnWriteArrayList&lt;Books&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder = new IBookManager.Stub()&#123; @Override public List&lt;Books&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Books books) throws RemoteException &#123; mBookList.add(books); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Books(1,\"艺术开发\")); mBookList.add(new Books(2,\"疯狂\")); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 可以看到，在服务端我们实例化一个CopyOnWriteArrayList对象mBookList，实现IBookManager接口，然后添加了两个book。还有要做的就是建立aidl文件夹及Books相关的aidl文件。 下面看看客户端的代码实现 1.3客户端 记得把Books相关aidl文件包全部烤过来。 BookManagerActivity代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class BookManagerActivity extends AppCompatActivity &#123; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; IBookManager bookManager = IBookManager.Stub.asInterface(iBinder); try &#123; List&lt;Books&gt; list = bookManager.getBookList(); Log.i(\"mzy\",\"list type = \"+list.getClass().getCanonicalName()); Log.i(\"mzy\",\"list string = \"+list.toString()); Books newBook = new Books(3,\"Android 境界\"); bookManager.addBook(newBook); Log.i(\"mzy\",\"add book \"+newBook); List&lt;Books&gt; newList = bookManager.getBookList(); Log.i(\"mzy\",\"new list \"+newList.toString()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //启动其他app的service Intent intent = new Intent(\"android.intent.action.BookManager\"); intent.setPackage(\"com.android.mzy.androidartsecond\"); bindService(intent,mConnection,BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; //别忘了注销 unbindService(mConnection); super.onDestroy(); &#125;&#125; 这样在启动BookManagerActivity的时候就会启动BookManagerService服务，并且实现了通信，跟接口使用一样一样的。 2 AIDL 实现观察者模式牛逼哄哄的观察者模式 提到接口的使用，那么我们可能会想到监听事件，也就是观察者模式。比如有这样的需求：每当service里面增加一本书，客户端就重新获取一次books列表。并且要求客户端可以监听和取消监听。 为了知道服务端添加了新书，我们需要写一个新的aidl接口IOnNewBookArrivedListener IOnNewBookArrivedListener.aidl代码： 12345678910111213// IOnNewBookArrivedListener.aidlpackage com.example.root.androidart.somethingAboutAidl.bookAidl;import com.example.root.androidart.somethingAboutAidl.bookAidl.Books;// Declare any non-default types here with import statementsinterface IOnNewBookArrivedListener &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void onNewBookArrived(in Books newBook);&#125; 为了能够注册监听和取消监听，我们需要对IBookManager.aidl进行改进，新增两个方法registerListener，和unregisterListener修改后的代码如下：IBookManager.aidl代码 12345678910111213// IBookManager.aidlpackage com.example.root.androidart.somethingAboutAidl.bookAidl;import com.example.root.androidart.somethingAboutAidl.bookAidl.Books;import com.example.root.androidart.somethingAboutAidl.bookAidl.IOnNewBookArrivedListener;// Declare any non-default types here with import statementsinterface IBookManager&#123; List&lt;Books&gt; getBookList(); void addBook(in Books books); void registerListener(IOnNewBookArrivedListener listener); void unregisterListener(IOnNewBookArrivedListener listener);&#125; 注意导包，即使在同一个包下也要导入。 2.1服务端 接下来实现服务端每5秒钟添加一本书。 BookManagerService.java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class BookManagerService extends Service &#123; private CopyOnWriteArrayList&lt;Books&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); private CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList = new CopyOnWriteArrayList&lt;&gt;(); private AtomicBoolean mIsServiceDestoryed = new AtomicBoolean(false); private Binder mBinder = new IBookManager.Stub()&#123; @Override public List&lt;Books&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Books books) throws RemoteException &#123; mBookList.add(books); &#125; @Override public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException &#123; if(!mListenerList.contains(listener))&#123; mListenerList.add(listener); &#125;else&#123; Log.i(\"mzy\",\"already exists\"); &#125; Log.i(\"mzy\",\"listener size \"+mListenerList.size()); &#125; @Override public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException &#123; if(mListenerList.contains(listener))&#123; mListenerList.remove(listener); Log.i(\"mzy\",\"unregister success\"); &#125;else&#123; Log.i(\"mzy\",\"not find ,can ont unregister\"); &#125; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Books(1,\"艺术\")); mBookList.add(new Books(2,\"疯狂\")); new Thread(new ServiceWorker()).start(); &#125; private class ServiceWorker implements Runnable&#123; @Override public void run() &#123; while (!mIsServiceDestoryed.get())&#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int bookId = mBookList.size()+1; Books newBook = new Books(bookId,\"newBook\"+bookId); try &#123; onNewBookArrived(newBook); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void onNewBookArrived(Books book) throws RemoteException &#123; mBookList.add(book); for (int i = 0; i &lt;mListenerList.size() ; i++) &#123; IOnNewBookArrivedListener listener = mListenerList.get(i); listener.onNewBookArrived(book); &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 看到ServiceWorker这个Runnable，完成了每隔5秒添加一个新的books对象。再看到onNewBookArrived方法。先在mBookList添加新书，然后遍历了mListenerList，之所以遍历mListenerList是因为该服务是可以实现一对多的交互的，也就是说，如果有多个客户端，那么服务端是要通知每个服务端新书到了的消息的。示例中只有一个客户端，所以这里的mListenerList.size为1. 其他的也没什么好说的，代码很简洁明了。就是增加了监听接口。 2.2 客户端修改 BookManagerActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class BookManagerActivity extends AppCompatActivity &#123; private static final int MESSAGE_NEW_BOOK_ARRIVED = 1; private IBookManager mBookManager; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case MESSAGE_NEW_BOOK_ARRIVED: Log.i(\"mzy\",\"receive new book \"+msg.obj); break; default:super.handleMessage(msg); &#125; &#125; &#125;; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; IBookManager bookManager = IBookManager.Stub.asInterface(iBinder); try &#123; mBookManager = bookManager; List&lt;Books&gt; list = bookManager.getBookList(); Log.i(\"mzy\",\"list type = \"+list.getClass().getCanonicalName()); Log.i(\"mzy\",\"list string = \"+list.toString()); Books newBook = new Books(3,\"Android 境界\"); bookManager.addBook(newBook); Log.i(\"mzy\",\"add book \"+newBook); List&lt;Books&gt; newList = bookManager.getBookList(); Log.i(\"mzy\",\"new list \"+newList.toString()); bookManager.registerListener(onNewBookArrivedListener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mBookManager = null; &#125; &#125;; private IOnNewBookArrivedListener onNewBookArrivedListener = new IOnNewBookArrivedListener.Stub() &#123; @Override public void onNewBookArrived(Books newBook) throws RemoteException &#123; mHandler.obtainMessage(MESSAGE_NEW_BOOK_ARRIVED,newBook).sendToTarget(); &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this,BookManagerService.class); bindService(intent,mConnection,BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; if(mBookManager != null &amp;&amp; mBookManager.asBinder().isBinderAlive())&#123; try &#123; mBookManager.unregisterListener(onNewBookArrivedListener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; unbindService(mConnection); super.onDestroy(); &#125;&#125; 看下改动了那些东西. 定义一个Handler对象mHandle处理接收信息 创建IOnNewBookArrivedListener接口对象onNewBookArrivedListener，mHandle处理接口的newBook。 bookManager添加了registerListener 参数为onNewBookArrivedListener。 在activity 销毁的时候注销了监听。 看了这个流程似乎就清晰了很多。代码里面还是有点绕。 但是！！！ 当退出activity的时候去发现控制台输出了如下打印 1androidart:BookManagerService I/mzy: not find ,can ont unregister 也就是说解除注册失败了！ 欲知后事，请看下回","tags":[]},{"title":"马平狮子茶叶面向全世界！","date":"2017-03-13T01:38:18.000Z","path":"2017/03/13/马平狮子茶叶面向全世界！/","text":"诚 交 茶 友插播广告一则，我姐家的茶叶，狮子茶叶 2006年开始我爸把马坪双河的一片山和一些地开发出来中了茶叶，在马坪狮子茶叶还是很有名气的，原因是茶叶地位于农村山丘之上，没有受到大城市的工业污染，加上茶农（我爸）的精心照料，茶叶味道清香纯正。 关于茶叶，最鲜最香的，要数春茶第一道，在谷雨时节前的茶叶都是经过严冬在春天开出的第一道茶叶。而现在我家的茶叶也该开始采摘了，在此希望能多交一些茶友，更希望马坪的狮子茶能走出马坪，走向世界！ 关于我家茶叶的一些承诺： 每年只采雨前茶（即“谷雨”以前的茶叶）； 无农药残留（冬季除虫卵）； 制作精细（龙井茶）； 量足，绝不缺斤少两； 不参杂旧茶或大厂茶； 原质原味，不添加色素和人工单宁添加剂； 价格300元/斤（量大从优） 如果你是送礼，我还可以为您精包装，只收成本费。 如果您爱喝茶，不妨试试，只要您留下您的 大名，地址，电话我爸爸将和老茶友一样，每年征询您的意见，直接快递到您手中，见货付款。如果您觉得有不如意的，可以拒收。真正让您实惠，省心，舒心，活（喝）得开心，我们要让您喝着茶，从内心发出感叹:“天下还有这样的好茶！” 联系电话:15971930361 王老师","tags":[]},{"title":"关于android进程间通信","date":"2017-03-12T02:41:18.000Z","path":"2017/03/12/关于android进程间通信/","text":"android开发中难免会遇到要求开发多进程的应用程序。在使用中总是缺少总结，以至于在遇到问题时只能依赖于google之类的。最近看了任玉刚老师的《Android开发艺术探索》这本书，第二章就讲到了多进程的通信方式，比较全面。那么我也对学过的东西总结一下吧。 1.使用Bundleandroid 在启动activity ，service，receiver时可以用Bundle实现进程间的通信，同过Intent为载体。这是进程间通信最简单的一种方式了。 Intent intent = new Intent(this,BookManagerService.class); Bundle bundle = new Bundle(); bundle.putString(&quot;bundle&quot;,&quot;hello ipc&quot;); intent.putExtras(bundle); bindService(intent,mConnection,BIND_AUTO_CREATE); 接着在BookManagerService里面根据intent获取到bundle携带的信息即可。 那么问题来了，既然这么简单那就用这种方式不就好了吗？ 然而在实际开发中并不止是传递一个字符这么简单。如果要传递一个对象呢？ 确实，我们发现Bundle在传递参数时是可以携带可序列化的对象的。 bundle.putParcelable(&quot;ParcelableClass&quot;,books); 这种方式在同一个进程里面是可行的，然鹅在多进程中就会出错了，会出现“Class not find”这种错误。原因是定义的boos类是属于当前进程的，其他进程获取不到，即使你把该类复制到新的进程里面也不可能被反序列化出来，因为在底层上他们已经不是同一个类了。 那么bundle到底支持哪些类型的数据呢？ 1.基本数据类型 2.可序列化的对象（实现了Parcellable接口，实现了 Serializable接口的对象） 3.以及一些Android支持的特殊对象 那么要在进程之间传递对象该怎么实现呢？ gson解析成json字符串然后传递 Intent intent = new Intent(this,BookManagerService.class); Bundle bundle = new Bundle(); Books books = new Books(1,&quot;ming&quot;); Gson gson = new Gson(); bundle.putString(&quot;bundle&quot;,gson.toJson(books)); intent.putExtras(bundle); bindService(intent,mConnection,BIND_AUTO_CREATE); 这里将可序列化的对象用gson转换为json字符串，实现使用bundle传递可序列化对象。在BookManagerService里面再获取到books对象 Bundle bundle = intent.getExtras(); Log.e(&quot;mzy&quot;,&quot;bundle.getString()&quot;+bundle.getString(&quot;bundle&quot;)); 但是书中没有提到使用json传递的方式来实现进程间通信。当然还是有更炫酷的实现方式，请往下看。 2.使用文件共享好吧，个人感觉这种方式其实并没有多大卵用，除非是一些长期需要使用的信息使用这种方式还是挺好的，作为缓存的方式。 这个就是一个进程写文件，一个进程读文件的方式实现进程间通信的。 大体就是用的Java读写文件的方式。很简单就不列出来了，但是使用的时候还是要注意一些事情的 1.并发读/写导致数据不是最新数据 2.并发写，导致数据错误 3.SharedPreferences也是一种文件读写的方式。这个用在文件共享实现进程通信是不可取的。因为系统会对SharedPreferences进行缓存，导致数据不是最新数据。 3.使用Messenger使用Messenger传递Message，可以实现进程间通信。其底层实现是AIDL，对AIDL进行了封装，使用起来比较简单。下面看看代码实现。 分为服务端和客户端两个进程 3.1服务端接收客户端消息3.1.1服务端进程在服务端创建一个Service来处理客户端的请求，创建一个Handle，并通过它来创建一个Messenger对象，再在Service的onBind中返回这个Messenger对象底层的Binder即可，说的太模糊，还是看服务端的代码吧 public class MessengerService extends Service { private static final String TAG = &quot;MessengerService&quot;; private static class MessengerHandler extends Handler{ @Override public void handleMessage(Message msg) { switch (msg.what){ case MyConstants.MSG_FROM_CLIENT : Bundle bundle1 = msg.getData(); Log.i(TAG,&quot;receive msg from Client :&quot;+bundle1.getString(&quot;msg&quot;)); break; default: super.handleMessage(msg); } } } private final Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) { return mMessenger.getBinder(); } } 内容不多用一个Handle创建一个Messenger，然后在onBInd里面返回Mes的BInder，handler里面处理接收到的信息 3.1.2客户端进程客户端首先要绑定服务端的Service，然后通过服务端返回的IBinder对象创建一个Messenger，就是通过这个Messenger对象给服务端发送消息的。，发送的消息类型为Message对象。 public class MessengerActivity extends AppCompatActivity { private static final String TAG = &quot;MessengerActivity&quot;; private Messenger messenger; //绑定Service private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { //获取Messenger messenger = new Messenger(iBinder); //创建Message Message msg = Message.obtain(null,MyConstants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(&quot;msg&quot;,&quot;hello i am client.&quot;); msg.setData(data); try { //发送消息 messenger.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName componentName) { //链接失败处理 } }; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MessengerActivity.this,MessengerService.class); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onDestroy() { //记得注销 unbindService(mConnection); super.onDestroy(); } } 好了，这样就实现了使用Messenger进程间通信了。不可以只是停留在客户端单相思的程度，当然要你来我往情意绵绵，那我们来实现一下互相之间的通信 3.2客户端与服务端交互道理其实都差不多的，服务端在收到消息以后再给客户端发送一条消息即可。 3.2.1服务端修改 public void handleMessage(Message msg) { switch (msg.what){ case MyConstants.MSG_FROM_CLIENT : Bundle bundle1 = msg.getData(); Log.i(TAG,&quot;receive msg from Client :&quot;+bundle1.getString(&quot;msg&quot;)); Messenger client = msg.replyTo; Message replyMessage = Message.obtain(null,MyConstants.MSG_FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(&quot;reply&quot;,&quot;ok i got your message&quot;); replyMessage.setData(bundle); try { client.send(replyMessage); } catch (RemoteException e) { e.printStackTrace(); } break; default: super.handleMessage(msg); } } 3.2.2客户端修改 public class MessengerActivity extends AppCompatActivity { private static final String TAG = &quot;MessengerActivity&quot;; private Messenger messenger; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { messenger = new Messenger(iBinder); Message msg = Message.obtain(null,MyConstants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(&quot;msg&quot;,&quot;hello i am client.&quot;); msg.setData(data); //将客户端的接收用的messenger传给服务端。 msg.replyTo = getReplyMessenger; try { messenger.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName componentName) { } }; private Messenger getReplyMessenger = new Messenger(new MessengerHandler()); private static class MessengerHandler extends Handler{ @Override public void handleMessage(Message msg) { switch (msg.what){ case MyConstants.MSG_FROM_SERVICE: Log.i(TAG,&quot;receive message from service :&quot;+msg.getData().getString(&quot;reply&quot;)); break; default: super.handleMessage(msg); } } } @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MessengerActivity.this,MessengerService.class); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onDestroy() { unbindService(mConnection); super.onDestroy(); } } 3.3Messenger实现多进程通信小结Messenger使用起来还是相对简单的。可以实现一对多的多进程通信（通过绑定Service）。但是由于其传递参数依赖于Bundle，所以传递的数据类型受到了限制。而且不能很好的处理高并发情况 4.使用AIDL要不先休息一下？下一篇再写AIDL吧。看个海贼先","tags":[]},{"title":"微信小程序radio不能改变大小，自己重写一个吧","date":"2017-02-25T06:02:35.000Z","path":"2017/02/25/微信小程序radio不能改变大小，自己重写一个吧/","text":"小程序自带的radio似乎是不能调整大小的，在项目中使用时很不方便，时常会影响整个界面的效果。为了解决这个问题，我使用text标签结合icon标签实现了radio效果。 这里我们实现一个选择地区的单选框 1.使用radio的效果可以清楚的看出来圆圈的大小和字体的大小非常不协调。至于radio如何实现的，这里就不赘述了，大家可以在官方教程中学习简易教程-小程序 2.使用text加 icon实现radio效果 先上效果图 这里的icon可以调整大小，调整位置。 接下来看看如何实现的吧。 思路：左边一个&lt; text&gt;右边一个&lt; icon&gt;来实现radio效果。以列表方式排列所有地区area，给地区设置isSelect属性，如果isSelect=true则显示的icon 的type为success否则icon的type显示circle。当text被点击时，根据area的id来确定被点击的text，被点击的text对应的area的isSelect属性设置为true否则设置为false。 先附上wxml文件代码部分： 123456789&lt;scroll-view hidden=&quot;&#123;&#123;hideArea&#125;&#125;&quot; scroll-y=&quot;true&quot; style=&quot;height: 100px;&quot; bindscrolltoupper=&quot;upper&quot; bindscrolltolower=&quot;lower&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; scroll-top=&quot;&#123;&#123;scrollTop&#125;&#125;&quot;&gt; &lt;view class=&quot;radio-group&quot; &gt; &lt;label wx:for=&quot;&#123;&#123;areas&#125;&#125;&quot; wx:for-item=&quot;area&quot;&gt; &lt;text bindtap=&quot;selectAreaOk&quot; data-areaId=&quot;&#123;&#123;area.id&#125;&#125;&quot;&gt;&#123;&#123;area.name&#125;&#125;&lt;/text&gt; &lt;icon wx:if=&quot;&#123;&#123;area.isSelect&#125;&#125;&quot; type=&quot;success&quot; size=&quot;10&quot;/&gt; &lt;icon wx:else type=&quot;circle&quot; size=&quot;10&quot;/&gt; &lt;/label&gt; &lt;/view&gt;&lt;/scroll-view&gt; 先设定一个scroll-view，设置选择框的父容器位置大小其中radio-group的wxss设定了容器内字体大小已经排练方式 12345.radio-group&#123; font-size: 26rpx; display: flex; flex-direction: column; &#125; 接下来遍历了areas数组用来显示 地区名称+icon 其中为地区名称 &lt; text&gt;设置了 bindtap、data-areaId 。这里要跟js进行数据交互，其中data-areaId为传递过去的参数。 根据area对象的isSelect属性来确定显示的&lt; icon&gt;,其中一个是圆圈，一个是绿色的对勾。示例中icon的大小设置为10，这里可以随意改变其大小。 接下来是js代码部分。 12345678910111213141516171819//选择区域 selectAreaOk: function(event)&#123; var selectAreaId = event.target.dataset.areaid; var that = this areaId = selectAreaId for(var i = 0;i&lt;this.data.areas.length;i++)&#123; if(this.data.areas[i].id==selectAreaId)&#123; this.data.areas[i].isSelect=true &#125;else&#123; this.data.areas[i].isSelect=false &#125; &#125; this.setData(&#123; areas:this.data.areas, skus:[], hideArea:true &#125;) getSkus(that,selectAreaId) &#125; 在js代码里面接收text的点击事件并接收到传递过来的参数，遍历areas数组，将选中的area的isSelect属性设置为true，其余设置为false，再刷新wxml的areas部分。 ok就这么简单。","tags":[]},{"title":"android release版本去掉log","date":"2017-02-25T05:58:27.000Z","path":"2017/02/25/android-release版本去掉log/","text":"android开发中总会在代码中添加log，打印当前运行情况。log打印是调试时不可或缺的工具。 但是不可否认的是当log打印语句中出现空指针的时候程序会crash。又或是在循环里面打印了log信息，会消耗很多系统资源。 目标：我们希望在打包debug包的时候保留log信息，在release包时去掉log消息。 方法：在使用AS创建android项目以后在目录app\\build\\generated\\source\\buildConfig\\debug\\com…..上会创建一个BuildConfig.java文件，里面有一个静态常量叫做 DEBUG。利用这个常量来实现打带签名的release包时去掉log消息的目的。 在使用log时，用以下方式使用： 123if(BuildConfig.DEBUG)&#123; Log.i(&quot;xxx&quot;,&quot;xxxxx&quot;); &#125; 实验证明方法的实用性： 试验方法：两条log打印，一条带BuildConfig.DEBUG判断，一条不带。 打debug包，反编译apk文件看看文件中是否有log语句。 打release包，反编译apk文件看看文件中是否有log语句。 内容不多mainActivity，两条log信息，相互对比以下。代码如下 12345678910111213public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(BuildConfig.DEBUG)&#123; Log.i(&quot;mzy&quot;,&quot;is show debug?&quot;); &#125; Log.d(&quot;mzy&quot;,&quot;show me&quot;); &#125;&#125; 1.打包debug版本的apk文件,然后进行反编译 反编译的mainActivity内容如下：可以看到，在debug版本中反编译apk得到的文件中两次log打印都还在。也就是在debug版本中，加上BuildConfig.DEBUG判断是没有影响的。 2.打包带签名的release版本，再反编译 反编译的mainActivity内容如下： 可以看到，在这次的反编译文件中只显示了一次log打印，显示的是没有添加BuidConfig.DEBUG的那一句。 结论：在添加了BuildConfig.DEBUG判断后的log信息是不会被编译到apk文件中的。 说明：该方法是在一个android技术群里学习到的。非原创。我只是方法的实现者。","tags":[]},{"title":"android与web交互的一些事","date":"2017-02-25T01:14:11.000Z","path":"2017/02/25/android与web交互的一些事/","text":"网页与Android原生页交互越来越多，遇到的问题也越来越多。 问题描述1：用户在app端登录成功，然后在app端打开一个需要登录信息（用来识别用户）的web页。 解决方案：app端发送js消息给web端，将用户登录的token值传递给web页。web页在调用需要登录信息的接口时设置请求头信息。关于Android如何传递参数给web请参照上一篇h5与Android原生交互这里Android端将token值发送到web页，web页处理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt; function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125;else&#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function () &#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; bridge.init(function (message, responseCallback) &#123; alert(&quot;message&quot;+message) document.cookie=&quot;token=&quot;+message; // alert(&apos;token\\ \\ &apos;+message); $.ajax(&#123; url:&apos;/xxxx/xxxxx/xxxxx/&apos;, type:&apos;GET&apos;, beforeSend:function(xhr)&#123; alert(&quot;beforeSend &quot;+message) xhr.setRequestHeader(&apos;Authorization&apos;,&apos;token\\ \\ &apos;+message) &#125;, success:function(resp)&#123; alert(&quot;success &quot;+message) dealResp(resp,message) &#125;, error:function(err)&#123; // alert(&quot;err&quot;) console.log(err) &#125; &#125;) var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; new Vue(&#123; el: &quot;#vue-app&quot;, template: &quot;#app-template&quot;, data:&#123; tab: 1, &#125;, events: &#123; &apos;bridgeEvt&apos;: function(obj) &#123; bridge.send(JSON.stringify(obj),function(responseData)&#123; console.log(responseData); &#125;) &#125; &#125;, ready: function()&#123; if(/notice_type=2/.test(location.href)) &#123; this.tab = 2 &#125; &#125;, &#125;); responseCallback(data) &#125;) &#125;)&lt;/script&gt; 这里主要看一下对message的处理，&lt; !–more– &gt;首先吧token值存到cookie里面，这样其他的页面都可以通过cookie来获取到登录token了。然后ajax get请求的时候设置请求头信息xhr.setRequestHeader(‘Authorization’,’token\\ \\ ‘+message)这个键值对是需要后台来识别登录信息的。 问题描述2：app端打开的web页又跳转了好几个web页，点击返回键所有的页面都被关闭了，直接返回到了原生页面。（老版本的微信的公众号推出的文章就有这个问题，现在已经修复了） 解决方案：1.Android端重写当前web所在的activity的onBackPressed()方法 12345678@Override public void onBackPressed() &#123; if(null != mWebView &amp;&amp; mWebView.canGoBack())&#123; mWebView.goBack(); &#125;else&#123; super.onBackPressed(); &#125; &#125; 这样可以实现网页的后退。 but没那么简单。问题并不是这么简单就解决了。你会发现当你返回到上一个web页面的时候你的ajax请求的数据不会变！（比如在第一个页面你是要认证，第二个页面处理完认证，第一个页面的认证需要变成已认证）这里数据不能重新获取的原因是，通过webView.goBack()方法是不会发送js数据的。因此不会去执行请求数据的ajax请求。 2web端因为cookie值是网页通用的（同网段），所以在接收js数据的web页面也通过cookie获取一次token。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;script&gt; function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function () &#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; var cookieToken = document.cookie.split(&quot;;&quot;)[0].split(&quot;token=&quot;)[1]; alert(&quot;cookieToken = &quot;+cookieToken); if(cookieToken)&#123; $.ajax(&#123; url:&apos;/xxxxx/xxxx/xxxxxx/&apos;, type:&apos;GET&apos;, beforeSend:function(xhr)&#123; // alert(&quot;beforeSend&quot;) xhr.setRequestHeader(&apos;Authorization&apos;,&apos;token\\ \\ &apos;+cookieToken) &#125;, success:function(resp)&#123; // alert(&quot;success&quot;) dealResp(resp,cookieToken) &#125;, error:function(err)&#123; // alert(&quot;err&quot;) console.log(err) &#125; &#125;) &#125; bridge.init(function (message, responseCallback) &#123; alert(&quot;message&quot;+message) document.cookie=&quot;token=&quot;+message; // alert(&apos;token\\ \\ &apos;+message); $.ajax(&#123; url:&apos;/xxxxx/xxx/xxxxxx/&apos;, type:&apos;GET&apos;, beforeSend:function(xhr)&#123; alert(&quot;beforeSend &quot;+message) xhr.setRequestHeader(&apos;Authorization&apos;,&apos;token\\ \\ &apos;+message) &#125;, success:function(resp)&#123; alert(&quot;success &quot;+message) dealResp(resp,message) &#125;, error:function(err)&#123; // alert(&quot;err&quot;) console.log(err) &#125; &#125;) var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; new Vue(&#123; el: &quot;#vue-app&quot;, template: &quot;#app-template&quot;, data:&#123; tab: 1, &#125;, events: &#123; &apos;bridgeEvt&apos;: function(obj) &#123; bridge.send(JSON.stringify(obj),function(responseData)&#123; console.log(responseData); &#125;) &#125; &#125;, ready: function()&#123; if(/notice_type=2/.test(location.href)) &#123; this.tab = 2 &#125; &#125;, &#125;); responseCallback(data) &#125;) &#125;)&lt;/script&gt; 至此web页返回上一页即可刷新数据了。如果还是无法刷新，请查看一下Android端webView的加载方式。设置为无缓存模式即可1mWebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE); 你以为Android与web的缠绵就此结束了吗？请看下面的问题 问题描述3：用户退出当前账号，换一个账号之后，web页获取的信息是前一个用户的信息？？ 解决方案：原因：前一个用户打开了web页，cookie被赋值了，后一个用户登录再打开web页时依然使用的是前一个用户的cookie所以web页获取的信息依然是前一个用户的信息。解决方法：在web页返回到Android原生页面的时候将webView的cookie值清除。 Android代码重写onBackPressed()方法。 12345678910@Override public void onBackPressed() &#123; if(null != mWebView &amp;&amp; mWebView.canGoBack())&#123; mWebView.goBack(); &#125;else&#123; CookieSyncManager.createInstance(mContext); CookieManager.getInstance().removeAllCookie(); super.onBackPressed(); &#125; &#125; 并且需要让webView不留缓存。 1mWebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE); 暂时遇到的问题就这么多，还有问题会再补充。如果有更好的解决方案，还望各路大神指点。","tags":[]},{"title":"h5页面与Android原生页面交互","date":"2017-02-25T01:10:21.000Z","path":"2017/02/25/h5页面与Android原生页面交互/","text":"Android页面内嵌套h5页面已经是随处可见了。在Android原生页面和h5页面的取舍上那些不是本文的重点。重点是，如此多的页面用网页来写，那么必定涉及到网页与原生的交互，俗称js交互。 目标：h5页面点击按钮Android端接收到网页传给的json数据。实现 网页端 网页端添加如下内容 123456789101112131415161718192021222324252627282930313233&lt;script type=&quot;text/javascript&quot;&gt; var hasBridge = false function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function () &#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; bridge.init(function (message, responseCallback) &#123; hasBridge = true var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; $(&quot;#document .disabled&quot;).removeClass(&quot;disabled&quot;) responseCallback(data) &#125;) $(&quot;#mzy&quot;).click(function()&#123; var sendObj = &#123;&quot;type&quot;:&quot;user&quot;&#125;； sendObj[&quot;phone&quot;] = &quot;18067976937&quot;; sendObj[&quot;nick&quot;] = &quot;maoamao&quot;; bridge.send(JSON.stringify(sendObj), function (responseData) &#123; &#125;); &#125;) &#125;)&lt;/script&gt; 其中 mzy 是定义的一个id = “mzy”的按钮。传递的json数据为 12345&#123; &quot;type&quot;:&quot;user&quot;, &quot;phone&quot;:&quot;18067976937&quot;, &quot;nick&quot;:&quot;maoamao&quot;,&#125; Android端 Android端这里使用的github上开元项目BridgeWebView来显示h5页面。使用如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647webview.setWebViewClient(new BridgeWebViewClient(webview) &#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; super.onPageStarted(view, url, favicon); &#125; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); &#125; @Override public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) &#123; super.onReceivedError(view, errorCode, description, failingUrl); view.loadData(errorHtml, &quot;text/html; charset=UTF-8&quot;, null); &#125; &#125;); //JS交互 webview.setDefaultHandler(new DefaultHandler() &#123; @Override public void handler(String data, CallBackFunction function) &#123; super.handler(data, function); Log.e(&quot;data&quot;, &quot;data = &quot; + data); try &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES) .setDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;).create(); JSONObject jsonObject = new JSONObject(data); String type = jsonObject.getString(&quot;type&quot;); if (null != type &amp;&amp; type.equals(&quot;user&quot;)) &#123; String nick = jsonObject.getString(&quot;nick&quot;); Log.i(&quot;nick&quot;,&quot;nick = &quot;+nick); &#125; else if (null != type &amp;&amp; type.equals(&quot;XXXXXX&quot;)) &#123; xxxxxxxx; &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); webview.loadUrl(&quot;XXXXXXXXXX&quot;); webview.send(&quot;hello-javascript&quot;); 这里根据因为同一个页面可能会有多种不同的交互需求，所以这里用type来区分不同的交互类型。这里可以根据jsonObject.getString(“nick”)获取到nick字段。 webview.loadUrl(“XXXXXXXXXX”);设置成你自己的h5页面地址即可。 目标二：Android端传递参数给web页 上面代码块里面最后一句webview.send(“hello-javascript”);就是Android端发送了一个”hello-javascript”字符串给web页。 web页接收Android发来的参数 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function()&#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; bridge.init(function (message, responseCallback) &#123; alert(&quot;message&quot;+message) var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; new Vue(&#123; el: &quot;#vue-app&quot;, template: &quot;#app-template&quot;, data:&#123; tab: 1, &#125;, events: &#123; &apos;bridgeEvt&apos;: function(obj) &#123; bridge.send(JSON.stringify(obj),function(responseData)&#123; console.log(responseData); &#125;) &#125; &#125;, ready: function()&#123; if(/notice_type=2/.test(location.href)) &#123; this.tab = 2 &#125; &#125;, &#125;); responseCallback(data) &#125;) &#125;)&lt;/script&gt; 其中alert(“message”+message)message就是从Android传过来的参数。我们可以进行处理。","tags":[]}]