[{"title":"微信小程序radio不能改变大小，自己重写一个吧","date":"2017-02-25T06:02:35.000Z","path":"2017/02/25/微信小程序radio不能改变大小，自己重写一个吧/","text":"小程序自带的radio似乎是不能调整大小的，在项目中使用时很不方便，时常会影响整个界面的效果。为了解决这个问题，我使用text标签结合icon标签实现了radio效果。 这里我们实现一个选择地区的单选框 1.使用radio的效果可以清楚的看出来圆圈的大小和字体的大小非常不协调。至于radio如何实现的，这里就不赘述了，大家可以在官方教程中学习简易教程-小程序 2.使用text加 icon实现radio效果 先上效果图 这里的icon可以调整大小，调整位置。 接下来看看如何实现的吧。 思路：左边一个&lt; text&gt;右边一个&lt; icon&gt;来实现radio效果。以列表方式排列所有地区area，给地区设置isSelect属性，如果isSelect=true则显示的icon 的type为success否则icon的type显示circle。当text被点击时，根据area的id来确定被点击的text，被点击的text对应的area的isSelect属性设置为true否则设置为false。 先附上wxml文件代码部分： 123456789&lt;scroll-view hidden=&quot;&#123;&#123;hideArea&#125;&#125;&quot; scroll-y=&quot;true&quot; style=&quot;height: 100px;&quot; bindscrolltoupper=&quot;upper&quot; bindscrolltolower=&quot;lower&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; scroll-top=&quot;&#123;&#123;scrollTop&#125;&#125;&quot;&gt; &lt;view class=&quot;radio-group&quot; &gt; &lt;label wx:for=&quot;&#123;&#123;areas&#125;&#125;&quot; wx:for-item=&quot;area&quot;&gt; &lt;text bindtap=&quot;selectAreaOk&quot; data-areaId=&quot;&#123;&#123;area.id&#125;&#125;&quot;&gt;&#123;&#123;area.name&#125;&#125;&lt;/text&gt; &lt;icon wx:if=&quot;&#123;&#123;area.isSelect&#125;&#125;&quot; type=&quot;success&quot; size=&quot;10&quot;/&gt; &lt;icon wx:else type=&quot;circle&quot; size=&quot;10&quot;/&gt; &lt;/label&gt; &lt;/view&gt;&lt;/scroll-view&gt; 先设定一个scroll-view，设置选择框的父容器位置大小其中radio-group的wxss设定了容器内字体大小已经排练方式 12345.radio-group&#123; font-size: 26rpx; display: flex; flex-direction: column; &#125; 接下来遍历了areas数组用来显示 地区名称+icon 其中为地区名称 &lt; text&gt;设置了 bindtap、data-areaId 。这里要跟js进行数据交互，其中data-areaId为传递过去的参数。 根据area对象的isSelect属性来确定显示的&lt; icon&gt;,其中一个是圆圈，一个是绿色的对勾。示例中icon的大小设置为10，这里可以随意改变其大小。 接下来是js代码部分。 12345678910111213141516171819//选择区域 selectAreaOk: function(event)&#123; var selectAreaId = event.target.dataset.areaid; var that = this areaId = selectAreaId for(var i = 0;i&lt;this.data.areas.length;i++)&#123; if(this.data.areas[i].id==selectAreaId)&#123; this.data.areas[i].isSelect=true &#125;else&#123; this.data.areas[i].isSelect=false &#125; &#125; this.setData(&#123; areas:this.data.areas, skus:[], hideArea:true &#125;) getSkus(that,selectAreaId) &#125; 在js代码里面接收text的点击事件并接收到传递过来的参数，遍历areas数组，将选中的area的isSelect属性设置为true，其余设置为false，再刷新wxml的areas部分。 ok就这么简单。","tags":[]},{"title":"android release版本去掉log","date":"2017-02-25T05:58:27.000Z","path":"2017/02/25/android-release版本去掉log/","text":"android开发中总会在代码中添加log，打印当前运行情况。log打印是调试时不可或缺的工具。 但是不可否认的是当log打印语句中出现空指针的时候程序会crash。又或是在循环里面打印了log信息，会消耗很多系统资源。 目标：我们希望在打包debug包的时候保留log信息，在release包时去掉log消息。 方法：在使用AS创建android项目以后在目录app\\build\\generated\\source\\buildConfig\\debug\\com…..上会创建一个BuildConfig.java文件，里面有一个静态常量叫做 DEBUG。利用这个常量来实现打带签名的release包时去掉log消息的目的。 在使用log时，用以下方式使用： 123if(BuildConfig.DEBUG)&#123; Log.i(&quot;xxx&quot;,&quot;xxxxx&quot;); &#125; 实验证明方法的实用性： 试验方法：两条log打印，一条带BuildConfig.DEBUG判断，一条不带。 打debug包，反编译apk文件看看文件中是否有log语句。 打release包，反编译apk文件看看文件中是否有log语句。 内容不多mainActivity，两条log信息，相互对比以下。代码如下 12345678910111213public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(BuildConfig.DEBUG)&#123; Log.i(&quot;mzy&quot;,&quot;is show debug?&quot;); &#125; Log.d(&quot;mzy&quot;,&quot;show me&quot;); &#125;&#125; 1.打包debug版本的apk文件,然后进行反编译 反编译的mainActivity内容如下：可以看到，在debug版本中反编译apk得到的文件中两次log打印都还在。也就是在debug版本中，加上BuildConfig.DEBUG判断是没有影响的。 2.打包带签名的release版本，再反编译 反编译的mainActivity内容如下： 可以看到，在这次的反编译文件中只显示了一次log打印，显示的是没有添加BuidConfig.DEBUG的那一句。 结论：在添加了BuildConfig.DEBUG判断后的log信息是不会被编译到apk文件中的。 说明：该方法是在一个android技术群里学习到的。非原创。我只是方法的实现者。","tags":[]},{"title":"android与web交互的一些事","date":"2017-02-25T01:14:11.000Z","path":"2017/02/25/android与web交互的一些事/","text":"网页与Android原生页交互越来越多，遇到的问题也越来越多。 问题描述1：用户在app端登录成功，然后在app端打开一个需要登录信息（用来识别用户）的web页。 解决方案：app端发送js消息给web端，将用户登录的token值传递给web页。web页在调用需要登录信息的接口时设置请求头信息。关于Android如何传递参数给web请参照上一篇h5与Android原生交互这里Android端将token值发送到web页，web页处理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt; function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125;else&#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function () &#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; bridge.init(function (message, responseCallback) &#123; alert(&quot;message&quot;+message) document.cookie=&quot;token=&quot;+message; // alert(&apos;token\\ \\ &apos;+message); $.ajax(&#123; url:&apos;/xxxx/xxxxx/xxxxx/&apos;, type:&apos;GET&apos;, beforeSend:function(xhr)&#123; alert(&quot;beforeSend &quot;+message) xhr.setRequestHeader(&apos;Authorization&apos;,&apos;token\\ \\ &apos;+message) &#125;, success:function(resp)&#123; alert(&quot;success &quot;+message) dealResp(resp,message) &#125;, error:function(err)&#123; // alert(&quot;err&quot;) console.log(err) &#125; &#125;) var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; new Vue(&#123; el: &quot;#vue-app&quot;, template: &quot;#app-template&quot;, data:&#123; tab: 1, &#125;, events: &#123; &apos;bridgeEvt&apos;: function(obj) &#123; bridge.send(JSON.stringify(obj),function(responseData)&#123; console.log(responseData); &#125;) &#125; &#125;, ready: function()&#123; if(/notice_type=2/.test(location.href)) &#123; this.tab = 2 &#125; &#125;, &#125;); responseCallback(data) &#125;) &#125;)&lt;/script&gt; 这里主要看一下对message的处理，&lt; !–more– &gt;首先吧token值存到cookie里面，这样其他的页面都可以通过cookie来获取到登录token了。然后ajax get请求的时候设置请求头信息xhr.setRequestHeader(‘Authorization’,’token\\ \\ ‘+message)这个键值对是需要后台来识别登录信息的。 问题描述2：app端打开的web页又跳转了好几个web页，点击返回键所有的页面都被关闭了，直接返回到了原生页面。（老版本的微信的公众号推出的文章就有这个问题，现在已经修复了） 解决方案：1.Android端重写当前web所在的activity的onBackPressed()方法 12345678@Override public void onBackPressed() &#123; if(null != mWebView &amp;&amp; mWebView.canGoBack())&#123; mWebView.goBack(); &#125;else&#123; super.onBackPressed(); &#125; &#125; 这样可以实现网页的后退。 but没那么简单。问题并不是这么简单就解决了。你会发现当你返回到上一个web页面的时候你的ajax请求的数据不会变！（比如在第一个页面你是要认证，第二个页面处理完认证，第一个页面的认证需要变成已认证）这里数据不能重新获取的原因是，通过webView.goBack()方法是不会发送js数据的。因此不会去执行请求数据的ajax请求。 2web端因为cookie值是网页通用的（同网段），所以在接收js数据的web页面也通过cookie获取一次token。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;script&gt; function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function () &#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; var cookieToken = document.cookie.split(&quot;;&quot;)[0].split(&quot;token=&quot;)[1]; alert(&quot;cookieToken = &quot;+cookieToken); if(cookieToken)&#123; $.ajax(&#123; url:&apos;/xxxxx/xxxx/xxxxxx/&apos;, type:&apos;GET&apos;, beforeSend:function(xhr)&#123; // alert(&quot;beforeSend&quot;) xhr.setRequestHeader(&apos;Authorization&apos;,&apos;token\\ \\ &apos;+cookieToken) &#125;, success:function(resp)&#123; // alert(&quot;success&quot;) dealResp(resp,cookieToken) &#125;, error:function(err)&#123; // alert(&quot;err&quot;) console.log(err) &#125; &#125;) &#125; bridge.init(function (message, responseCallback) &#123; alert(&quot;message&quot;+message) document.cookie=&quot;token=&quot;+message; // alert(&apos;token\\ \\ &apos;+message); $.ajax(&#123; url:&apos;/xxxxx/xxx/xxxxxx/&apos;, type:&apos;GET&apos;, beforeSend:function(xhr)&#123; alert(&quot;beforeSend &quot;+message) xhr.setRequestHeader(&apos;Authorization&apos;,&apos;token\\ \\ &apos;+message) &#125;, success:function(resp)&#123; alert(&quot;success &quot;+message) dealResp(resp,message) &#125;, error:function(err)&#123; // alert(&quot;err&quot;) console.log(err) &#125; &#125;) var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; new Vue(&#123; el: &quot;#vue-app&quot;, template: &quot;#app-template&quot;, data:&#123; tab: 1, &#125;, events: &#123; &apos;bridgeEvt&apos;: function(obj) &#123; bridge.send(JSON.stringify(obj),function(responseData)&#123; console.log(responseData); &#125;) &#125; &#125;, ready: function()&#123; if(/notice_type=2/.test(location.href)) &#123; this.tab = 2 &#125; &#125;, &#125;); responseCallback(data) &#125;) &#125;)&lt;/script&gt; 至此web页返回上一页即可刷新数据了。如果还是无法刷新，请查看一下Android端webView的加载方式。设置为无缓存模式即可1mWebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE); 你以为Android与web的缠绵就此结束了吗？请看下面的问题 问题描述3：用户退出当前账号，换一个账号之后，web页获取的信息是前一个用户的信息？？ 解决方案：原因：前一个用户打开了web页，cookie被赋值了，后一个用户登录再打开web页时依然使用的是前一个用户的cookie所以web页获取的信息依然是前一个用户的信息。解决方法：在web页返回到Android原生页面的时候将webView的cookie值清除。 Android代码重写onBackPressed()方法。 12345678910@Override public void onBackPressed() &#123; if(null != mWebView &amp;&amp; mWebView.canGoBack())&#123; mWebView.goBack(); &#125;else&#123; CookieSyncManager.createInstance(mContext); CookieManager.getInstance().removeAllCookie(); super.onBackPressed(); &#125; &#125; 并且需要让webView不留缓存。 1mWebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE); 暂时遇到的问题就这么多，还有问题会再补充。如果有更好的解决方案，还望各路大神指点。","tags":[]},{"title":"h5页面与Android原生页面交互","date":"2017-02-25T01:10:21.000Z","path":"2017/02/25/h5页面与Android原生页面交互/","text":"Android页面内嵌套h5页面已经是随处可见了。在Android原生页面和h5页面的取舍上那些不是本文的重点。重点是，如此多的页面用网页来写，那么必定涉及到网页与原生的交互，俗称js交互。 目标：h5页面点击按钮Android端接收到网页传给的json数据。实现 网页端 网页端添加如下内容 123456789101112131415161718192021222324252627282930313233&lt;script type=&quot;text/javascript&quot;&gt; var hasBridge = false function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function () &#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; bridge.init(function (message, responseCallback) &#123; hasBridge = true var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; $(&quot;#document .disabled&quot;).removeClass(&quot;disabled&quot;) responseCallback(data) &#125;) $(&quot;#mzy&quot;).click(function()&#123; var sendObj = &#123;&quot;type&quot;:&quot;user&quot;&#125;； sendObj[&quot;phone&quot;] = &quot;18067976937&quot;; sendObj[&quot;nick&quot;] = &quot;maoamao&quot;; bridge.send(JSON.stringify(sendObj), function (responseData) &#123; &#125;); &#125;) &#125;)&lt;/script&gt; 其中 mzy 是定义的一个id = “mzy”的按钮。传递的json数据为 12345&#123; &quot;type&quot;:&quot;user&quot;, &quot;phone&quot;:&quot;18067976937&quot;, &quot;nick&quot;:&quot;maoamao&quot;,&#125; Android端 Android端这里使用的github上开元项目BridgeWebView来显示h5页面。使用如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647webview.setWebViewClient(new BridgeWebViewClient(webview) &#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; super.onPageStarted(view, url, favicon); &#125; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); &#125; @Override public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) &#123; super.onReceivedError(view, errorCode, description, failingUrl); view.loadData(errorHtml, &quot;text/html; charset=UTF-8&quot;, null); &#125; &#125;); //JS交互 webview.setDefaultHandler(new DefaultHandler() &#123; @Override public void handler(String data, CallBackFunction function) &#123; super.handler(data, function); Log.e(&quot;data&quot;, &quot;data = &quot; + data); try &#123; Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES) .setDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&quot;).create(); JSONObject jsonObject = new JSONObject(data); String type = jsonObject.getString(&quot;type&quot;); if (null != type &amp;&amp; type.equals(&quot;user&quot;)) &#123; String nick = jsonObject.getString(&quot;nick&quot;); Log.i(&quot;nick&quot;,&quot;nick = &quot;+nick); &#125; else if (null != type &amp;&amp; type.equals(&quot;XXXXXX&quot;)) &#123; xxxxxxxx; &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); webview.loadUrl(&quot;XXXXXXXXXX&quot;); webview.send(&quot;hello-javascript&quot;); 这里根据因为同一个页面可能会有多种不同的交互需求，所以这里用type来区分不同的交互类型。这里可以根据jsonObject.getString(“nick”)获取到nick字段。 webview.loadUrl(“XXXXXXXXXX”);设置成你自己的h5页面地址即可。 目标二：Android端传递参数给web页 上面代码块里面最后一句webview.send(“hello-javascript”);就是Android端发送了一个”hello-javascript”字符串给web页。 web页接收Android发来的参数 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener(&apos;WebViewJavascriptBridgeReady&apos;, function()&#123; callback(WebViewJavascriptBridge) &#125;, false) &#125; &#125; connectWebViewJavascriptBridge(function (bridge) &#123; bridge.init(function (message, responseCallback) &#123; alert(&quot;message&quot;+message) var data = &#123;&apos;Javascript Responds&apos;: &apos;Wee!&apos;&#125; new Vue(&#123; el: &quot;#vue-app&quot;, template: &quot;#app-template&quot;, data:&#123; tab: 1, &#125;, events: &#123; &apos;bridgeEvt&apos;: function(obj) &#123; bridge.send(JSON.stringify(obj),function(responseData)&#123; console.log(responseData); &#125;) &#125; &#125;, ready: function()&#123; if(/notice_type=2/.test(location.href)) &#123; this.tab = 2 &#125; &#125;, &#125;); responseCallback(data) &#125;) &#125;)&lt;/script&gt; 其中alert(“message”+message)message就是从Android传过来的参数。我们可以进行处理。","tags":[]}]